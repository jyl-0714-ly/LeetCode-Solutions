class Solution {
    /*
    题目：283.移动零
    给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

    注：请注意 ，必须在不复制数组的情况下原地对数组进行操作。
    */
    public void moveZeroes(int[] nums) {
        /*
        思路1：利用类似冒泡法的思路，双循环，当nums[i]为0时，每次与他的下一个数nums[i-1]对比，两种情况：
        情况一：当nums[i-1]=0时，那么就以nums[i-1]为基准，继续往下对比。
        情况二：当nums[i-1]!=0时，那么nums[i]与nums[i-1]交换位置。
        这样进行对比下去，就可以把一个为0的数，给移动到数组最后，并且不改变非零元素的相对位置，且满足不复制数组。
        */
        int len = nums.length;//先得知数组长度，以便于得知数组循环次数
        for (int i = 0; i < len; i++) {//从头开始，避免错漏
            for (int j = i + 1; j < len; j++) {//从i+1开始，是i的下一个，相邻的形成对照
                if (nums[i] == 0 && nums[j] != 0) {//满足条件交换位置
                    nums[i] = nums[j];
                    nums[j] = 0;
                }
            }
        }
    }
}

// class Solution {
//     /*
//     题目：283.移动零
//     给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

//     注：请注意 ，必须在不复制数组的情况下原地对数组进行操作。
//     */
//     public void moveZeroes(int[] nums) {
//         /*
//         思路2：定义两个指针i，j，使这两个指针都指向nums[0]，然后i开始向右移动，分为两种情况：
//         情况一：当nums[i]!=0的时候，使nums[j]=nums[i]，并且j向右移一位，i继续右移;
//         情况二：当nums[i]==0的时候，nums[j]不变化，i继续右移。
//         这样一次遍历下去，可以将非零元素全部移到nums数组的左边，并且在原数组上进行；
//         因为当i指针指向0的时：i右移，j不动；
//         那么当i遍历完后，j还未遍历完，此时j指向的元素，及其往后的元素，就是0的个数；
//         此时，将j指针指向的元素及往后的元素，全部赋值为0，至此完成。
//         */
//         int j = 0;
//         int len = nums.length;//计算数组长度，以此得到遍历条件
//         for (int i = 0; i < len; i++) {//一次遍历
//             if (nums[i] != 0) {//条件，i指针指向不为0的元素的时候，将i指针指向的元素赋值给j指针指向的元素，然后j指针右移
//                 nums[j] = nums[i];
//                 j++;
//             }
//         }
//         for (int i = j; i < len; i++) {//遍历完后，开始给j指针指向位置，及其之后元素赋为0
//             nums[i] = 0;
//         }
//     }
// }