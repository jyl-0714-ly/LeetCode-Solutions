class Solution {
    /*
    152.乘积最大子数组          
    给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

    测试用例的答案是一个 32-位 整数。
    请注意，一个只包含一个元素的数组的乘积是这个元素的值。
    */
    public int maxProduct(int[] nums) {
        /*
        思路：动态规划
        要求最大子数组，遍历数组开始，每个元素挨个相乘，当都为正数时有乘积最大值，当存在负数时，有乘积最小值，当遇到负数时，
        最大值和最小值要交换，并且不断记录遍历过程中最大值。当遇到负数交换后，最大值经过负数，再遇到正数时，会从新开始计算子数组，
        然后再次累计最大值，和原先的最大值对比，而此时最小值也一直在往小的方向发展，当再次遇到负数时，两者以此类推再次交换，
        每轮的最大值都会被记录下去，遍历一轮后，留下的就是最大值。
        */
        int ans = Integer.MIN_VALUE;
        int fMax = 1;
        int fMin = 1;
        for(int x : nums){
            if(x < 0){//遇到负数，最大值和最小值交换
                int tmp = fMax;
                fMax = fMin;
                fMin = tmp;
            }
            //如果遇到负数先前连续的子数组被从中打断，当遇到下一个正数时，从这个正数开始计算子数组乘积。
            //如果没遇到，就一直乘积下去
            fMax = Math.max(fMax * x, x);
            //如果遇到负数就取到最大值和这个负数相乘，而后乘积积累下去，当再次遇到时，负负得正，把积累的值连本带利还给最大值
            //如果没遇到，就记载每轮的值
            fMin = Math.min(fMin * x, x);
            //记载每一次遍历所得到的最大值，最后留下的就是乘积最大子数组的值
            ans = Math.max(fMax,ans);
        }
        return ans;
    }
}