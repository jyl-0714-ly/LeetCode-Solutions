class Solution {
    /*
    题目：给定两个字符串s和p，找到s中所有p的异位词的子串，返回这些子串的起始索引。
    
    注：不考虑答案输出的顺序；s、p仅包含小写字母。
    */
    public List<Integer> findAnagrams(String s, String p) {
    /*
    思路：根据题目，可知是要求：在字符串s中寻找字符串p的异位词。

    因为字符串p的异位词与字符串p长度相当，所以可以在字符串s中构造滑动窗口，并维持滑动窗口中字母的个数，
    当窗口中的字母的数量以及大小，与字符串p中的字母大小和数量相同，那么则说明当前窗口是字符串p的异位词。
    */
        //1.计算字符串s、p的长度
        int slen = s.length();
        int plen = p.length();
        //1.1建立窗口以与p个数相当的字母，滑动存储这些字母。以及另一个存储字符串p的字母。
        int[] son = new int[26];
        int[] pon = new int[26];
        //1.2建立集合存储寻找结果
        List<Integer> list = new ArrayList<>();
        //1.3提前排除不适合的因素。当字符串p的长度，大于字符串s的长度，不可能存在异位词，因此排除。
        if(plen>slen){
            return list;
        }
        //2.以字符串p的长度为准，依次向son滑动窗口中添加字母，并且也向pon窗口中添加字母。
        //但是pon窗口固定，仅用作和son对照，而son是滑动窗口，后续需要不断变化存储内容。
        for(int i = 0; i<plen; i++){
            ++son[s.charAt(i)-'a'];
            ++pon[p.charAt(i)-'a'];
        }
        //2.1也是提前排除小概率因素，能够提高效率。在两个窗口相等时，说明第一轮添加就有异位词，则add的是0。
        if(Arrays.equals(son,pon)){
            list.add(0);
        }
        //3.此时需要遍历整个字符串s，以确保不会遗漏字符串p的异位词。
        for(int i = 0; i<slen - plen; i++){
            //3.1因为已经通过2.1判断过第一个元素开头的组合元素是不是异位词，
            //因此可以直接跳过，即减去开头元素。
            //组合元素：即以第i个元素开头，选取与字符串p长度相同的元素，组成的字符串。
            --son[s.charAt(i)-'a'];
            //3.2当减去开头元素后再在此组合元素后面添加一个元素，保证组合元素与字符串p的长度相同。
            //这样3.1与3.2一加一减，就是滑动窗口了
            ++son[s.charAt(i+plen)-'a'];
            //3.2判断新组合窗口是否与pon这个固定窗口相同，
            //同则添加此时的开头元素的索引，即i+1(因为i=0已经在2.1判断过，故+1)
            //不同则下一轮滑动
            if(Arrays.equals(son,pon)){
                list.add(i+1);
            }
        }
        //4.返回集合
        return list;
    }
}