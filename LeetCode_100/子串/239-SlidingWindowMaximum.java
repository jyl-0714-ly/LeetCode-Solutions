class Solution {
    /*
    题目：239.滑动窗口最大值
    给你一个整数数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。
    你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位。

    注：返回滑动窗口中的最大值 。
    */
    public int[] maxSlidingWindow(int[] nums, int k) {
    /*
    思路：假设滑动窗口区间为[i,j]。当窗口向右滑动一格，区间变为：[i+1,j+1]。即添加了nums[j+1],删除了nums[i]。
    因为每次都需要求[i,j]或者[i+1,j+1]区间内的最大值，并将最大值添加到数组中。

    现在的问题是，每次向右移动一格后：
    ①怎么确定删除的是不是最大值？
    ②添加的是不是最大值？
    ③如果删除和添加都不是最大值，那么怎么求最大值？

    首先根据题目可以想到用对应双端队列。
    可以利用循环，添加nums数组元素到队尾，而后再次利用循环使数组元素与队尾元素对比，如果数组元素大于队尾元素，就删除队尾元素。
    这样可以保证使窗口内元素的最大值，永远都排在队头，而且还给队列元素给排序了。(一下解决了解决问题②③)

    那么还有个问题①，该怎么判断队头元素是不是该删除了？
    可以用一个if判断，当对头元素(peetFirst()) == 要删除的元素(nums[i])，就表明现在这个对头元素该删除了，
    因为上一步队列元素排序了，所以当删除队头元素后，下一个队头元素，就是窗口内最大值。
    */
        int len = nums.length;//计算数组长度，方便后续利用
        if(len == 0 || k == 0){//首先排除特殊条件，增加运行效率
            return new int[0];
        }
        Deque<Integer> dq = new LinkedList<>();//创建双向队列，存储元素
        int[] arr = new int[len - k + 1];//因为滑动窗口长度为k，每次移动一格，所以有len-k+1这么长
        for(int i = 0; i<k; i++){//先给队列添加一个窗口的元素
            while(!dq.isEmpty() && dq.peekLast() < nums[i]){
            //当窗口不为空，同时队尾元素小于要添加的元素时，删除队尾元素，能给队列元素排序，保证对头元素始终为队列内最大值
                dq.removeLast();
            }
            dq.addLast(nums[i]);//不管如何，添加当前元素到队尾
        }
        arr[0] = dq.peekFirst();//初始化队列的第一个窗口的最大值，放到数组第一个里面
        for(int i = k; i<len; i++){//遍历剩余的数组
            if(dq.peekFirst() == nums[i-k]){//解决问题①，当对头这个最大值等于即将删除的数组元素时，就删除对头元素
                dq.removeFirst();
            }
            while(!dq.isEmpty() && dq.peekLast() < nums[i]){
            //当窗口不为空，同时队尾元素小于要添加的元素时，删除队尾元素，能给队列元素排序，保证对头元素始终为队列内最大值
                dq.removeLast();
            }
            dq.addLast(nums[i]);//不管如何，添加当前元素到队尾
            arr[i - k + 1] = dq.peekFirst();//添加窗口内的最大值到数组中
        }
        return arr;//返回数组
    }
}