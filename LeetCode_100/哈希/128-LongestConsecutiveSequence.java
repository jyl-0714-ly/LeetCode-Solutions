class Solution {
    /*
    题目：128.最长连续序列
    给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

    注：请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
    */
    public int longestConsecutive(int[] nums) {
        /*
        思路：利用TreeSet能够自动排序的特性，先将数组元素全部添加的TreeSet集合中；
        然后再遍历集合，利用连续数字相邻相减为1的性质，进行计算连续的个数。

        为了解决一个数组中，有多组连续的数字，可以设置条件，当计算一组连续的数中断后，
        再创建一个TreeSet集合，把这组数的长度添加到集合中，然后把计数的标准count再次归位，
        然后再次重新计算下一组，然后结束后，再次把count添加到TreeSet集合中。
        最后返回TreeSet集合的最后一个数，可利用last()函数，此数即为最终结果。
        */
        if(nums == null || nums.length == 0){//先排除数组为空，避免集合为空和减少运算
            return 0;
        }
        TreeSet<Integer> ts1 = new TreeSet<>();//建立第一个集合，用来排序
        int len = nums.length;//计算数组长度，以便循环
        for(int i = 0; i<len; i++){//将数组元素添加到集合中，而后排序
            ts1.add(nums[i]);
        }
        TreeSet<Integer> ts2 = new TreeSet<>();//创建第二个集合，用来装数组中每组连续数的长度，并排序
        int t = ts1.first();//利用连续数相减为1的特性，t就做个存储上一个数，供下一个数相减
        int count = 1;//用来计数，计每组连续数的长度，因为两两相减，所以初始值为1
        for(int a : ts1){//遍历ts1
            if(a - t == 1){//设置条件，当这两个数相减为1时，便是连续的，此时count++
            count++;
            }
            if(count != 1 && a-t != 1){
            //此条件为，当数组中，这组连续数计数完毕时，换到下一组连续数，需要重新计数，
            //先把上一组的添加到，ts2中，然后把count归1，重新计算下一组的连续数
                ts2.add(count);
                count = 1;
            }
            t = a;//t存储上一个循环的a，依次供下一个循环的a相减
        }
        ts2.add(count);//将最后一组的连续数添加到ts2中，也很好的避免了ts2为空的条件
        return ts2.last();//最后返回集合中最大的连续数的个数
    }
}


// class Solution {
//     /*
//     题目：128.最长连续序列
//     给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

//     注：请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
//     */
//     public int longestConsecutive(int[] nums) {
//         /*
//         思路：利用HashSet的contains方法，能够快速查询，以及连续数之间相差为1的特性，
//         能够在得知一个集合中的数之后，能够查询这个数是否在数组中有连续数，并且得知连续数的个数。
//         因为一组连续数的个数最多是多少，要从开头元素算起，为了减少不必要的循环，就需要寻找开头元素
//         就可以通过一个条件，当一个元素-1存在于集合中时，说明这个元素不是开头元素，就跳过。
//         */
//         Set<Integer> set = new HashSet<>();//创建集合存储数组元素
//         for(int a : nums){//遍历数组，将数组元素存储到集合
//             set.add(a);
//         }
//         int d = 0;//因为一个数组中可能存在多组连续数，而d计的是最终最长的那组连续数的长度的值
//         for(int b : set){//遍历集合
//             if(set.contains( b - 1)){//当不是开头元素时，跳过循环
//                 continue;
//             }
//             int c = 0;//进行计数，计连续数的长度
//             while(set.contains(b++)){//能够到这里的元素，必定是开头元素，那么循环查找的就是连续数
//                 c++;//计连续数的长度
//             }
//             d = Math.max(d,c);//每次筛选出长度最大的连续数
//         }
//         return d;//返回长度最大的连续数
//     }
// }